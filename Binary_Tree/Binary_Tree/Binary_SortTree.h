#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

// 二叉排序树----BST（Binary Sort Tree）
// 一棵树的左子树上的所有结点的值都比根节点小；右子树上的所有结点的值都比根节点的值大；
// 同时，这个性质对于这棵树的所有子树都成立（递归性质）

// 构建BST：
// 对于这样一个数据：4、5、19、23、2、8
// 以4为根结点构建，然后将剩下的数字与4比较
//		5比4大：5作为4的右孩子
//		19比4大，同时比5大：19作为5的右孩子
//		23比4、5、19都大：23作为19的右孩子
//		2比4小：2作为4的左孩子
//		……
//		以此类推
//			4
//		2		5
//		  	  		19
//				  8		23
//


typedef struct Binary_SortTree BST;

struct Binary_SortTree {
	int val;
	BST* Lchild;
	BST* Rchild;
};

void BST_Insert(BST** RootNode, int data);	// 创建二叉排序树结点

BST* BST_Search(BST* RootNode, int key);	// 在二叉排序树中查找值

void PreOrder_BST(BST* RootNode);	// 前序遍历


// AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。
// AVL树（自平衡二叉查找树）是一种合理的二叉排序树
// 所谓合理，就是指能够用更高的效率去查找一颗树中的值
// 比如，对于这样一个数组：1、2、3、4、5
// 普通二叉查找树：
//		1
//			2
//				3
//					4
//						5
// 自平衡二叉查找树：
//			3
//		2		4
//	1				5
// 显然，对于两棵树同样查找一个数 5 时，自平衡二叉树的效率更高
// 这种自平衡，就代表这棵二叉树的左右子树的高度差不超过 1
//

// 1、构建一棵自平衡二叉排序树，本质上就是构建一棵普通二叉排序树
// 2、在构建过程中，如果发现树的高度差不符合特性（左右子树高度差不超过1），就需要进行调整
//		有四种情况：LL	RR	RL	 LR